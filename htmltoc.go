package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
)

var (
	in      = ""
	inHelp  = "Required html file name only, less the html extension."
	out     = ""
	outHelp = "Optional output file name only, which defaults to input name."
)

const (
	inExt   = ".html"
	outExt  = ".h"
	comment = `//
// DO NOT EDIT generated by github/centretown/htmltoc
//
`
	prefix = "const char* webpage = \"\\\n"
	suffix = "\";\n"
)

func init() {
	flag.StringVar(&in, "i", in, inHelp)
	flag.StringVar(&out, "o", out, outHelp)
}

func main() {
	flag.Parse()
	if in == "" {
		flag.Usage()
		return
	}

	if out == "" {
		out = in + outExt
	}

	if !strings.HasSuffix(in, inExt) {
		in = in + inExt
	}
	if !strings.HasSuffix(out, outExt) {
		out = out + outExt
	}
	flag.VisitAll(func(f *flag.Flag) {
		fmt.Printf("%s=%v\n", f.Name, f.Value)
	})

	err := convert(in, out)
	if err != nil {
		log.Fatalln(err)
	}
}

type delimiter struct {
	start, end string
}

type delimiters []delimiter

type segment struct {
	start, end int
}

type segments []*segment

var comments = delimiters{
	{start: "/*", end: "*/"},
	{start: "// ", end: "\n"},
	{start: "\n// ", end: "\n"},
	{start: "<!--", end: "-->"},
}

func (del *delimiter) locate(s string, idx int) (seg *segment) {
	max := len(s)
	seg = &segment{start: -1, end: -1}
	if idx < 0 || idx >= max {
		return
	}
	start := strings.Index(s[idx:], del.start)
	if start < 0 {
		return
	}
	start += idx
	seg.start = start
	end := strings.Index(s[start:], del.end)
	if end < 0 {
		if del.end != "\n" {
			return
		}
	}

	if end < 0 {
		seg.end = max
		return
	}
	end += len(del.end)
	seg.end = start + end
	return
}

func (del *delimiter) strip(s string) string {
	var (
		bldr  strings.Builder
		slen  int
		segs  segments
		seg   *segment
		start int
	)

	slen = len(s)

	for i := 0; i < slen; {
		seg := del.locate(s, i)
		if seg.start == -1 || seg.end < seg.start {
			break
		}
		segs = append(segs, seg)
		i = seg.end
	}

	start = 0
	for _, seg = range segs {
		if seg.start > start {
			bldr.WriteString(s[start:seg.start])
		}
		start = seg.end
	}

	nsegs := len(segs)
	if nsegs > 0 {
		seg = segs[nsegs-1]
		bldr.WriteString(s[seg.end:])
	} else {
		bldr.WriteString(s)
	}

	return bldr.String()
}

func (dels delimiters) stripComments(s string) (r string) {
	r = s
	for _, del := range dels {
		r = del.strip(r)
	}
	return
}

func reduce(s string) (r string) {
	// strip comments
	s = comments.stripComments(s)

	// fix quotes for c/cpp
	replacer := strings.NewReplacer(`"`, `\"`)
	s = replacer.Replace(s)

	// strip newlines
	replacer = strings.NewReplacer("\n", " ")
	s = replacer.Replace(s)

	// strip blanks
	replacer = strings.NewReplacer("  ", " ")
	prev := len(s)
	i := 0
	for cur := prev - 1; prev > cur; i++ {
		fmt.Printf("i=%d prev=%d cur=%d\n", i, prev, cur)
		prev = cur
		s = replacer.Replace(s)
		cur = len(s)
	}

	r = comment + prefix + s + suffix
	return
}

func convert(in, out string) (err error) {
	b, err := ioutil.ReadFile(in)
	if err != nil {
		return
	}

	s := reduce(string(b))

	err = ioutil.WriteFile(out, []byte(s), os.ModePerm)
	return
}
